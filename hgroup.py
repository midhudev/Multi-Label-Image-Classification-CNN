# -*- coding: utf-8 -*-
import skimage.io
import skimage.feature
import skimage.color
import skimage.transform
import skimage.util
import skimage.segmentation
import numpy
from main import main
from skimage.segmentation import mark_boundaries
import matplotlib.pyplot as plt


##############################################################################################################
#   ---------------------   Extract regions from the segments------------------------------------------------
#############################################################################################################
def find_get_regions(img):

    R = {}

    # get hsv image
    hsv = skimage.color.rgb2hsv(img[:, :, :3])

    # pass 1: count pixel positions
    for y, i in enumerate(img):
        # print y,i

        for x, (r, g, b, l) in enumerate(i):

            # initialize a new region
            # print x,y,l
            if l not in R:

                R[l] = {
                    "x1": 0xffff, "y1": 0xffff,
                    "x2": 0, "y2": 0, "labels": [l]}

            # bounding box
            if R[l]["x1"] > x:
                R[l]["x1"] = x
            if R[l]["y1"] > y:
                R[l]["y1"] = y
            if R[l]["x2"] < x:
                R[l]["x2"] = x
            if R[l]["y2"] < y:
                R[l]["y2"] = y

    # pass 2: calculate texture gradient
    tex_grad = _calc_texture_gradient(img)

    # pass 3: calculate colour histogram of each region
    for k, v in R.items():

        # colour histogram
        masked_pixels = hsv[:, :, :][img[:, :, 3] == k]
        R[k]["size"] = len(masked_pixels / 4)
        R[k]["hist_c"] = _calc_colour_hist(masked_pixels)

        # texture histogram
        R[k]["hist_t"] = _calc_texture_hist(tex_grad[:, :][img[:, :, 3] == k])

    return R


###############################################################################################################
## --------------------------- Extract all the neighbours of the regions---------------------------------------
###############################################################################################################

def find_get_neighbours(regions):

    def intersect(a, b):
        if (a["x1"] < b["x1"] < a["x2"]
                and a["y1"] < b["y1"] < a["y2"]) or (
            a["x1"] < b["x2"] < a["x2"]
                and a["y1"] < b["y2"] < a["y2"]) or (
            a["x1"] < b["x1"] < a["x2"]
                and a["y1"] < b["y2"] < a["y2"]) or (
            a["x1"] < b["x2"] < a["x2"]
                and a["y1"] < b["y1"] < a["y2"]):
            return True
        return False

    R = regions.items()
    neighbours = []
    for cur, a in enumerate(R[:-1]):
        for b in R[cur + 1:]:
            if intersect(a[1], b[1]):
                neighbours.append((a, b))

    return neighbours


def combine_regions(r1, r2):
    new_size = r1["size"] + r2["size"]
    rt = {
        "x1": min(r1["x1"], r2["x1"]),
        "y1": min(r1["y1"], r2["y1"]),
        "x2": max(r1["x2"], r2["x2"]),
        "y2": max(r1["y2"], r2["y2"]),
        "size": new_size,
        "hist_c": (
            r1["hist_c"] * r1["size"] + r2["hist_c"] * r2["size"]) / new_size,
        "hist_t": (
            r1["hist_t"] * r1["size"] + r2["hist_t"] * r2["size"]) / new_size,
        "labels": r1["labels"] + r2["labels"]
    }
    return rt


#################################################################################################################
##---------------- Get all the segments generated by huttenlocheralgorithm --------------------------------------
#################################################################################################################

def find_segments(inp_image, scale, sigma, min_size):
    """
        segment smallest regions by the algorithm of Felzenswalb and
        Huttenlocher
    """

    # open the Image
    im_mask = skimage.segmentation.felzenszwalb(
        skimage.util.img_as_float(inp_image), scale=scale, sigma=sigma,
        min_size=min_size)
    # im_mask=main(inp_image,scale,min_size,sigma)
    # print (numpy.unique(im_mask))
    # for each in im_mask:
        # print each
    # print "mask",im_mask
    # print len(im_mask)
    # fig, ax = plt.subplots(2, 2, figsize=(10, 10), sharex=True, sharey=True,
    #                    subplot_kw={'adjustable': 'box-forced'})
    # ax[0, 0].imshow(mark_boundaries(inp_image, im_mask))

    # for a in ax.ravel():
    #     a.set_axis_off()

    # plt.tight_layout()
    # plt.show()
    # merge mask channel to the image as a 4th channel
    inp_image = numpy.append(
        inp_image, numpy.zeros(inp_image.shape[:2])[:, :, numpy.newaxis], axis=2)
    inp_image[:, :, 3] = im_mask
    # print inp_image
    return inp_image


##################################################################################################################
#   Similarity measures 
###################################################################################################################

def _sim_colour(r1, r2):
    """
        calculate the sum of histogram intersection of colour
    """
    return sum([min(a, b) for a, b in zip(r1["hist_c"], r2["hist_c"])])


def _sim_texture(r1, r2):
    """
        calculate the sum of histogram intersection of texture
    """
    return sum([min(a, b) for a, b in zip(r1["hist_t"], r2["hist_t"])])


def _sim_size(r1, r2, imsize):
    """
        calculate the size similarity over the image
    """
    return 1.0 - (r1["size"] + r2["size"]) / imsize


def _sim_fill(r1, r2, imsize):
    """
        calculate the fill similarity over the image
    """
    bbsize = (
        (max(r1["x2"], r2["x2"]) - min(r1["x1"], r2["x1"]))
        * (max(r1["y2"], r2["y2"]) - min(r1["y1"], r2["y1"]))
    )
    return 1.0 - (bbsize - r1["size"] - r2["size"]) / imsize


def similarity_calcu(r1, r2, imsize):
    return (_sim_colour(r1, r2) + _sim_texture(r1, r2)
            + _sim_size(r1, r2, imsize) + _sim_fill(r1, r2, imsize))


def _calc_colour_hist(img):

    BINS = 25
    hist = numpy.array([])

    for colour_channel in (0, 1, 2):

        # extracting one colour channel
        c = img[:, colour_channel]

        # calculate histogram for each colour and join to the result
        hist = numpy.concatenate(
            [hist] + [numpy.histogram(c, BINS, (0.0, 255.0))[0]])

    # L1 normalize
    hist = hist / len(img)

    return hist


def _calc_texture_gradient(img):
    """
        calculate texture gradient for entire image

        The original SelectiveSearch algorithm proposed Gaussian derivative
        for 8 orientations, but we use LBP instead.

        output will be [height(*)][width(*)]
    """
    ret = numpy.zeros((img.shape[0], img.shape[1], img.shape[2]))

    for colour_channel in (0, 1, 2):
        ret[:, :, colour_channel] = skimage.feature.local_binary_pattern(
            img[:, :, colour_channel], 8, 1.0)

    return ret


def _calc_texture_hist(img):
    """
        calculate texture histogram for each region

        calculate the histogram of gradient for each colours
        the size of output histogram will be
            BINS * ORIENTATIONS * COLOUR_CHANNELS(3)
    """
    BINS = 10

    hist = numpy.array([])

    for colour_channel in (0, 1, 2):

        # mask by the colour channel
        fd = img[:, colour_channel]

        # calculate histogram for each orientation and concatenate them all
        # and join to the result
        hist = numpy.concatenate(
            [hist] + [numpy.histogram(fd, BINS, (0.0, 1.0))[0]])

    # L1 Normalize
    hist = hist / len(img)

    return hist


#################################################################################################################
##  Call from the "iou_test_v1" main program
#################################################################################################################


def hierarchical(
        inp_image, scale=1.0, sigma=0.8, min_size=50):
    '''Selective Search

    Parameters
    ----------
        inp_image : ndarray
            Input image
        scale : int
            Free parameter. Higher means larger clusters in felzenszwalb segmentation.
        sigma : float
            Width of Gaussian kernel for felzenszwalb segmentation.
        min_size : int
            Minimum component size for felzenszwalb segmentation.
    Returns
    -------
        img : ndarray
            image with region label
            region label is stored in the 4th value of each pixel [r,g,b,(region)]
        regions : array of dict
            [
                {
                    'rect': (left, top, right, bottom),
                    'labels': [...]
                },
                ...
            ]
    '''
    assert inp_image.shape[2] == 3, "3ch image is expected"

    # load image and get smallest regions
    # region label is stored in the 4th value of each pixel [r,g,b,(region)]
    img = find_segments(inp_image, scale, sigma, min_size)
    # print img
    if img is None:
        return None, {}

    imsize = img.shape[0] * img.shape[1]
    R = find_get_regions(img)
    # print R
    # extract neighbouring information
    neighbours = find_get_neighbours(R)
    # print neighbours

    # calculate initial similarities
    S = {}
    for (ai, ar), (bi, br) in neighbours:
        # print (ai, ar), (bi, br)
        S[(ai, bi)] = similarity_calcu(ar, br, imsize)

    # hierarchal search
    while S != {}:

        # get highest similarity
        i, j = sorted(S.items(), cmp=lambda a, b: cmp(a[1], b[1]))[-1][0]

        # merge corresponding regions
        t = max(R.keys()) + 1.0
        R[t] = combine_regions(R[i], R[j])

        # mark similarities for regions to be removed
        key_to_delete = []
        for k, v in S.items():
            if (i in k) or (j in k):
                key_to_delete.append(k)

        # remove old similarities of related regions
        for k in key_to_delete:
            del S[k]

        # calculate similarity set with the new region
        for k in filter(lambda a: a != (i, j), key_to_delete):
            n = k[1] if k[0] in (i, j) else k[0]
            S[(t, n)] = similarity_calcu(R[t], R[n], imsize)

    regions = []
    for k, r in R.items():
        regions.append({
            'rect': (
                r['x1'], r['y1'],
                r['x2'] - r['x1'], r['y2'] - r['y1']),
            'size': r['size'],
            'labels': r['labels']
        })

    return img, regions

################################################################################################################